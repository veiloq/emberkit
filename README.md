# emberkit - Go PostgreSQL Integration Testing Toolkit

`emberkit` is a Go testing toolkit designed to simplify integration testing with PostgreSQL. It manages embedded PostgreSQL database instances, providing a clean and isolated environment for each test run, ensuring reliable and repeatable tests without external dependencies.

## Project Structure

```
.
├── .gitignore           # Git ignore patterns
├── .goreleaser.yml      # GoReleaser configuration for releases
├── atlas.hcl            # Atlas HCL configuration (optional, for schema management)
├── emberkit_test.go     # Top-level tests for the EmberKit struct
├── emberkit.go          # Deprecated entry point (use kit.go)
├── go.mod               # Go module definition
├── go.sum               # Go module checksums
├── kit.go               # Main entry point: Defines the EmberKit struct and core methods
├── LICENSE              # Project license (MIT)
├── README.md            # This file
├── sqlc.yaml            # sqlc configuration (optional, for code generation from SQL)
├── atlas/               # Atlas migration tool integration
│   ├── atlas_test.go    # Tests for Atlas integration
│   ├── atlas.go         # Atlas migrator implementation
│   └── options.go       # Configuration options specific to Atlas
├── config/              # Configuration management for EmberKit
│   ├── config.go        # Defines the main Config struct
│   └── options.go       # Functional options for configuring EmberKit
├── connection/          # Database connection management
│   ├── connection.go    # Handles connection string generation and details
│   └── port.go          # Dynamic port allocation for isolated instances
├── db/                  # Core database server management
│   ├── database.go      # Functions for creating/dropping test databases
│   └── server.go        # Manages the embedded PostgreSQL server process
├── internal/            # Internal helper packages
│   ├── cleanup/         # Resource cleanup logic (temp dirs, server process)
│   │   └── cleanup.go
│   └── logger/          # Internal logging setup
│       └── logger.go
├── migration/           # Generic migration interface and runner
│   └── migrator.go      # Defines the Migrator interface
├── migrations/          # Default directory for database migration files
│   ├── 20240101000000_init.sql # Example initial migration
│   └── atlas.sum        # Atlas migration checksum file
└── snippets/            # Example usage snippets (used in tests/documentation)
    ├── db.go            # Generated by sqlc
    ├── models.go        # Generated by sqlc
    ├── queries.sql      # Example SQL queries for sqlc
    └── queries.sql.go   # Go code generated by sqlc from queries.sql
```
## Installation

Pre-compiled binaries for various operating systems are available on the [GitHub Releases page](https://github.com/veiloq/emberkit/releases). Please download the binary corresponding to the latest release version suitable for your system.

## Versioning

This project uses Calendar Versioning (CalVer) with the format `vMAJOR.YYYYMM.PATCH`.

*   `MAJOR`: Incremented for breaking changes.
*   `YYYYMM`: Represents the year and month of the release.
*   `PATCH`: Incremented for bug fixes and minor changes within the same month.


## Basic Usage

Here's a basic example demonstrating how to use `emberkit` in a Go test:

```go
package main_test

import (
	"context"
	"database/sql" // Needed for RunSQLTx example
	"testing"

	"github.com/jackc/pgx/v5" // Needed for RunTx example
	"github.com/stretchr/testify/require"
	"github.com/veiloq/emberkit/atlas" // If using Atlas migrations
	"github.com/veiloq/emberkit/config"
	"github.com/veiloq/emberkit/kit"
)

// TestMyFeatureWithEmberKit demonstrates basic usage of EmberKit.
func TestMyFeatureWithEmberKit(t *testing.T) {
	// 1. Configure EmberKit (often defaults are sufficient)
	cfg := config.Config{
		// Customize paths, user, etc. if needed
		// BinPath:     "/path/to/postgres/bin",
		// DataDir:     "/tmp/emberkit-data",
		// MigrationsDir: "db/migrations",
		AutoMigrate: true, // Assumes migrations exist in default 'migrations' dir
	}

	// 2. Initialize EmberKit, potentially with options like Atlas integration
	// Use context.Background() or a test-specific context
	tk, err := kit.NewEmberKit(context.Background(), cfg, atlas.WithAtlas())
	require.NoError(t, err, "Failed to initialize EmberKit")

	// 3. Ensure automatic cleanup using t.Cleanup (recommended)
	t.Cleanup(tk.Cleanup) // Stops DB server, removes temp data

	// --- Example Test Case 1: Using pgx.Tx ---
	t.Run("CreateAndQueryUserWithPgx", func(t *testing.T) {
		tk.RunTx(t, func(ctx context.Context, tx pgx.Tx) {
			// Assume 'users' table exists due to AutoMigrate=true
			userName := "Alice"
			userEmail := "alice@example.com"

			// Insert a new user
			_, err := tx.Exec(ctx, "INSERT INTO users (name, email) VALUES ($1, $2)", userName, userEmail)
			require.NoError(t, err, "Failed to insert user")

			// Verify the user was inserted
			var count int
			err = tx.QueryRow(ctx, "SELECT COUNT(*) FROM users WHERE email = $1", userEmail).Scan(&count)
			require.NoError(t, err, "Failed to query user count")
			require.Equal(t, 1, count, "Expected exactly one user with email %s", userEmail)

			// Retrieve the user's ID (example of querying data)
			var userID int
			err = tx.QueryRow(ctx, "SELECT id FROM users WHERE email = $1", userEmail).Scan(&userID)
			require.NoError(t, err, "Failed to query user ID")
			require.Positive(t, userID, "User ID should be positive")
		})
		// Transaction is automatically rolled back here unless committed explicitly (not shown)
	})

	// --- Example Test Case 2: Using *sql.Tx ---
	t.Run("UpdateUserWithSqlTx", func(t *testing.T) {
		// Setup: Insert a user first (in a separate transaction for clarity)
		initialEmail := "bob@example.com"
		tk.RunTx(t, func(ctx context.Context, tx pgx.Tx) {
			_, err := tx.Exec(ctx, "INSERT INTO users (name, email) VALUES ($1, $2)", "Bob", initialEmail)
			require.NoError(t, err)
		})

		// Now, test updating the user within a *sql.Tx
		tk.RunSQLTx(t, func(ctx context.Context, tx *sql.Tx) {
			newName := "Robert"

			// Update the user's name
			result, err := tx.ExecContext(ctx, "UPDATE users SET name = $1 WHERE email = $2", newName, initialEmail)
			require.NoError(t, err, "Failed to update user name")

			rowsAffected, err := result.RowsAffected()
			require.NoError(t, err, "Failed to get rows affected")
			require.Equal(t, int64(1), rowsAffected, "Expected one row to be updated")

			// Verify the name was updated
			var updatedName string
			err = tx.QueryRowContext(ctx, "SELECT name FROM users WHERE email = $1", initialEmail).Scan(&updatedName)
			require.NoError(t, err, "Failed to query updated name")
			require.Equal(t, newName, updatedName, "Expected name to be updated")
		})
		// Transaction is automatically rolled back here
	})
}

```

This example shows how to set up `emberkit`, ensure cleanup, and run test logic within isolated database transactions using both `pgx` and standard `database/sql` interfaces. Remember to have your migrations (e.g., in a `migrations` directory) ready if `AutoMigrate` is enabled.

## Default Storage Locations

By default, `emberkit` uses the following locations:

*   **Runtime Data:** A unique temporary directory is created within `./.emberkit` (relative to the current working directory) for each dedicated test server instance. This directory is automatically removed during cleanup unless configured otherwise.
*   **PostgreSQL Binaries:** If not specified via the `BinariesPath` configuration option, the required PostgreSQL binaries are downloaded and cached by the underlying `embedded-postgres` library, typically within `~/.embedded-postgres-go/` in the user's home directory.
*   **Logs:** Internal `emberkit` logs and raw PostgreSQL output default to `os.Stderr`. If `NewEmberKit` is initialized with a `*testing.T`, internal logs use the test runner's logger (`zaptest`).
